//
// this file is automatically generated
//
package org.marketcetera.strategy;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Date;
import java.util.Optional;
import java.util.Set;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.Validate;
import org.marketcetera.admin.User;
import org.marketcetera.admin.dao.UserDao;
import org.marketcetera.admin.provisioning.ProvisioningAgent;
import org.marketcetera.admin.user.PersistentUser;
import org.marketcetera.cluster.ClusterData;
import org.marketcetera.cluster.service.ClusterService;
import org.marketcetera.core.PlatformServices;
import org.marketcetera.core.Preserve;
import org.marketcetera.core.file.DirectoryWatcherImpl;
import org.marketcetera.core.file.DirectoryWatcherSubscriber;
import org.marketcetera.eventbus.EventBusService;
import org.marketcetera.strategy.dao.PersistentStrategyInstance;
import org.marketcetera.strategy.dao.StrategyInstanceDao;
import org.marketcetera.strategy.events.SimpleStrategyStartFailedEvent;
import org.marketcetera.strategy.events.SimpleStrategyStartedEvent;
import org.marketcetera.strategy.events.SimpleStrategyStatusChangedEvent;
import org.marketcetera.strategy.events.SimpleStrategyUnloadedEvent;
import org.marketcetera.strategy.events.SimpleStrategyUploadFailedEvent;
import org.marketcetera.strategy.events.SimpleStrategyUploadSucceededEvent;
import org.marketcetera.strategy.events.StrategyEvent;
import org.marketcetera.util.log.SLF4JLoggerProxy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.eventbus.Subscribe;

/* $License$ */

/**
 * Provides StrategyServiceImpl services.
 *
 * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
 * @version $Id$
 * @since $Release$
 */
@Preserve
@Component
@AutoConfiguration
public class StrategyServiceImpl
        implements StrategyService,DirectoryWatcherSubscriber
{
    /**
     * Validate and start the object.
     *
     * @throws IOException if an error occurs managing strategy and provisioning directories 
     */
    @PostConstruct
    public void start()
            throws IOException
    {
        serviceName = PlatformServices.getServiceName(getClass());
        SLF4JLoggerProxy.info(this,
                              "{} starting",
                              serviceName);
        clusterData = clusterService.getInstanceData();
        strategyIncomingDirectoryName = strategyIncomingDirectoryName + clusterData.getInstanceNumber();
        incomingStrategyDirectoryPath = Paths.get(strategyIncomingDirectoryName);
        // intentionally not modified with the cluster instance number; it's ok if multiple instances use these directories
        storageStrategyDirectoryPath = Paths.get(strategyStorageDirectoryName);
        temporaryStrategyDirectoryPath = Paths.get(strategyTemporaryDirectoryName);
        FileUtils.createParentDirectories(storageStrategyDirectoryPath.toFile());
        SLF4JLoggerProxy.info(this,
                              "{} monitoring {} for uploaded strategies, storing strategies in {}, and using {} to start strategies",
                              serviceName,
                              strategyIncomingDirectoryName,
                              strategyStorageDirectoryName,
                              provisioningAgent.getProvisioningDirectory());
        strategyWatcher = new DirectoryWatcherImpl();
        strategyWatcher.setCreateDirectoriesOnStart(true);
        strategyWatcher.setDirectoriesToWatch(Lists.newArrayList(new File(strategyIncomingDirectoryName)));
        strategyWatcher.setPollingInterval(pollingInterval);
        strategyWatcher.addWatcher(this);
        strategyWatcher.start();
        eventBusService.register(this);
    }
    /**
     * Stop the object.
     */
    @PreDestroy
    public void stop()
    {
        eventBusService.unregister(this);
        if(strategyWatcher != null) {
            try {
                strategyWatcher.stop();
            } catch (Exception ignored) {
            } finally {
                strategyWatcher = null;
            }
        }
        SLF4JLoggerProxy.info(this,
                              "{} stopped",
                              serviceName);
    }
    /**
     * Requests loaded strategy instances.
     *
     * @returns a <code>Collection<StrategyInstance></code> value
     */
    @Override
    @Transactional(readOnly=true,propagation=Propagation.REQUIRED)
    public Collection<? extends StrategyInstance> getStrategyInstances(String inCurrentUserName)
    {
        // TODO need to filter by current user
        // TODO probably need to factor in supervisor permissions for "read"
        return strategyInstanceDao.findAll();
    }
    /**
     * Start a strategy instance.
     *
     * @param inStrategyInstanceName a <code>String</code> value
     */
    @Override
    @Transactional(readOnly=false,propagation=Propagation.REQUIRED)
    public void startStrategyInstance(String inStrategyInstanceName)
    {
        boolean success = true;
        String errorMessage = null;
        StrategyStatus newStatus = null;
        StrategyStatus oldStatus = null;
        PersistentStrategyInstance strategyInstance = null;
        try {
            Optional<PersistentStrategyInstance> strategyInstanceOption = strategyInstanceDao.findByName(inStrategyInstanceName);
            if(strategyInstanceOption.isEmpty()) {
                success = false;
                errorMessage = "No loaded strategy with name '" + inStrategyInstanceName + "'";
                newStatus = StrategyStatus.ERROR;
            } else {
                strategyInstance = strategyInstanceOption.get();
                oldStatus = strategyInstance.getStatus();
                if(strategyInstance.getStatus().isRunnable()) {
                    Path strategySource = Paths.get(strategyStorageDirectoryName,
                                                    strategyInstance.getFilename());
                    if(strategySource.toFile().canRead()) {
                        success = true;
                        newStatus = StrategyStatus.RUNNING;
                        // TODO somehow set the parameters for the strategy to read
                        Path strategyTargetDirectory = Paths.get(provisioningAgent.getProvisioningDirectory());
                        SLF4JLoggerProxy.info(this,
                                              "Starting strategy {} by copying {} to {}",
                                              strategyInstance.getName(),
                                              strategySource,
                                              strategyTargetDirectory);
                        FileUtils.copyFileToDirectory(strategySource.toFile(),
                                                      strategyTargetDirectory.toFile());
                        strategyInstance.setStarted(new Date());
                        newStatus = StrategyStatus.RUNNING;
                    } else {
                        success = false;
                        errorMessage = "Unable to read cached strategy with name '" + inStrategyInstanceName + "'";
                        newStatus = StrategyStatus.ERROR;
                        SLF4JLoggerProxy.warn(this,
                                              "Unable to read cached strategy '{}' with filename {}",
                                              inStrategyInstanceName,
                                              strategySource);
                    }
                } else {
                    success = false;
                    errorMessage = "Strategy '" + inStrategyInstanceName + "' at status " + oldStatus.name() + " cannot be started";
                    newStatus = oldStatus;
                }
            }
        } catch (RuntimeException | IOException e) {
            success = false;
            errorMessage = PlatformServices.getMessage(e);
            newStatus = StrategyStatus.ERROR;
        } finally {
            if(strategyInstance != null) {
                strategyInstance.setStatus(newStatus);
                strategyInstance = strategyInstanceDao.save(strategyInstance);
            }
            if(success) {
                eventBusService.post(new SimpleStrategyStartedEvent(strategyInstance));
            } else {
                eventBusService.post(new SimpleStrategyStartFailedEvent(strategyInstance,
                                                                        errorMessage));
            }
            if(oldStatus != newStatus) {
                eventBusService.post(new SimpleStrategyStatusChangedEvent(strategyInstance,
                                                                          oldStatus,
                                                                          newStatus));
            }
        }
    }
    /**
     * Stop a strategy instance.
     *
     * @param inStrategyInstanceName a <code>String</code> value
     */
    @Override
    @Transactional(readOnly=false,propagation=Propagation.REQUIRED)
    public void stopStrategyInstance(String inStrategyInstanceName)
    {
        throw new UnsupportedOperationException(); // TODO
    }
    /**
     * Unload a strategy instance.
     *
     * @param inStrategyInstanceName a <code>String</code> value
     */
    @Override
    @Transactional(readOnly=false,propagation=Propagation.REQUIRED)
    public void unloadStrategyInstance(String inStrategyInstanceName)
    {
        Validate.notNull(inStrategyInstanceName,
                         "Strategy instance name required");
        Optional<PersistentStrategyInstance> strategyInstanceOption = strategyInstanceDao.findByName(inStrategyInstanceName);
        Validate.isTrue(strategyInstanceOption.isPresent(),
                        "No strategy instance by name '" + inStrategyInstanceName + "'");
        PersistentStrategyInstance strategyInstance = strategyInstanceOption.get();
        Validate.isTrue(strategyInstance.getStatus().isUnloadable(),
                        "Strategy '" + strategyInstance.getName() + "' cannot be unloaded at status '" + strategyInstance.getStatus() + "'");
        // TODO need to put the correct filename in here
        Path strategyTarget = Paths.get(strategyStorageDirectoryName,
                                        strategyInstance.getFilename());
        FileUtils.deleteQuietly(strategyTarget.toFile());
        strategyInstanceDao.delete(strategyInstance);
        eventBusService.post(new SimpleStrategyUnloadedEvent(strategyInstance));
    }
    /* (non-Javadoc)
     * @see StrategyService#getIncomingStrategyDirectory()
     */
    @Override
    public Path getIncomingStrategyDirectory()
    {
        return incomingStrategyDirectoryPath;
    }
    /* (non-Javadoc)
     * @see StrategyService#getTemporaryStrategyDirectory()
     */
    @Override
    public Path getTemporaryStrategyDirectory()
    {
        return temporaryStrategyDirectoryPath;
    }
    /**
     * Load a new strategy instances.
     *
     * @param inStrategyInstance an <code>StrategyInstance</code> value
     * @returns an <code>StrategyStatus</code> value
     */
    @Override
    @Transactional(readOnly=false,propagation=Propagation.REQUIRED)
    public void received(File inFile,
                         String inOriginalFileName)
    {
        SLF4JLoggerProxy.debug(this,
                               "Received incoming strategy file '{}'",
                               inOriginalFileName);
        // TODO match with strategy instance and update status to LOADED or ERROR
        // verify and move to provisioning directory
        // find the incoming upload
//        Optional<? extends StrategyInstance> strategyInstanceOption = strategyService.findByName(inName);
//        Validate.isTrue(strategyInstanceOption.isPresent(),
//                        "No strategy instance with name '" + inName + "' found");
//        StrategyInstance strategyInstance = strategyInstanceOption.get();
//        Validate.isTrue(inNonce.equals(strategyInstance.getNonce()),
//                        "Strategy upload nonce does not match");
//        String hash = PlatformServices.getFileChecksum(inStrategyFile.toFile());
//        Validate.isTrue(hash.equals(strategyInstance.getHash()),
//                        "Strategy upload hash does not match");
        PersistentStrategyInstance strategyInstance = null;
        try {
            String nonce = FilenameUtils.getBaseName(inOriginalFileName);
            Optional<PersistentStrategyInstance> strategyInstanceOption = strategyInstanceDao.findByNonce(nonce);
            SLF4JLoggerProxy.debug(this,
                                   "Received uploaded file with nonce: '{}' found: {}",
                                   nonce,
                                   strategyInstanceOption);
            Validate.isTrue(strategyInstanceOption.isPresent(),
                            "No strategy instance with nonce: '" + nonce + "'");
            strategyInstance = strategyInstanceOption.get();
            // TODO should use the file type uploaded
            String finalStrategyFilename = nonce + ".jar";
            strategyInstance.setFilename(finalStrategyFilename);
            Path strategyTarget = Paths.get(strategyStorageDirectoryName,
                                            finalStrategyFilename);
            FileUtils.moveFile(inFile,
                               strategyTarget.toFile());
            StrategyStatus oldStatus = strategyInstance.getStatus();
            strategyInstance.setStatus(StrategyStatus.STOPPED);
            strategyInstance = strategyInstanceDao.save(strategyInstance);
            eventBusService.post(new SimpleStrategyUploadSucceededEvent(strategyInstance));
            eventBusService.post(new SimpleStrategyStatusChangedEvent(strategyInstance,
                                                                      oldStatus,
                                                                      strategyInstance.getStatus()));
        } catch (Exception e) {
            SLF4JLoggerProxy.warn(this,
                                  e);
            if(strategyInstance != null) {
                strategyInstance.setStatus(StrategyStatus.ERROR);
                strategyInstance = strategyInstanceDao.save(strategyInstance);
            }
            eventBusService.post(new SimpleStrategyUploadFailedEvent(strategyInstance,
                                                                     PlatformServices.getMessage(e)));
        }
    }
    /**
     * Load a new strategy instances.
     *
     * @param inStrategyInstance an <code>StrategyInstance</code> value
     * @returns an <code>StrategyStatus</code> value
     */
    @Override
    @Transactional(readOnly=false,propagation=Propagation.REQUIRED)
    public StrategyStatus loadStrategyInstance(StrategyInstance inStrategyInstance)
    {
        // create a new persistent strategy instance
        PersistentStrategyInstance pInstance;
        if(inStrategyInstance instanceof PersistentStrategyInstance) {
            pInstance = (PersistentStrategyInstance)inStrategyInstance;
        } else {
            throw new UnsupportedOperationException("Need to create persistent instance");
        }
        pInstance.setStatus(StrategyStatus.LOADING);
        PersistentUser user = userDao.findByName(inStrategyInstance.getUser().getName());
        Validate.notNull(user,
                         "No user for name '" + inStrategyInstance.getUser().getName() + "'");
        pInstance.setUser(user);
        pInstance = strategyInstanceDao.save(pInstance);
        return pInstance.getStatus();
    }
    /**
     * Receive incoming strategy events.
     *
     * @param inEvent a <code>StrategyEvent</code> value
     */
    @Subscribe
    public void receiveStrategyEvent(StrategyEvent inEvent)
    {
        synchronized(strategyEventListeners) {
            for(StrategyEventListener listener : strategyEventListeners) {
                try {
                    listener.receiveStrategyEvent(inEvent);
                } catch (Exception e) {
                    SLF4JLoggerProxy.warn(this,
                                          e);
                }
            }
        }
    }
    /* (non-Javadoc)
     * @see org.marketcetera.strategy.StrategyService#addStrategyEventListener(org.marketcetera.strategy.StrategyEventListener)
     */
    @Override
    public void addStrategyEventListener(StrategyEventListener inListener)
    {
        synchronized(strategyEventListeners) {
            strategyEventListeners.add(inListener);
        }
    }
    /* (non-Javadoc)
     * @see org.marketcetera.strategy.StrategyService#removeStrategyEventListener(org.marketcetera.strategy.StrategyEventListener)
     */
    @Override
    public void removeStrategyEventListener(StrategyEventListener inListener)
    {
        synchronized(strategyEventListeners) {
            strategyEventListeners.remove(inListener);
        }
    }
    /**
     * Finds the strategy instance with the given name.
     *
     * @param inName a <code>String</code> value
     * @returns a <code>Optional<? extends StrategyInstance></code> value
     */
    @Override
    @Transactional(readOnly=true,propagation=Propagation.REQUIRED)
    public Optional<? extends StrategyInstance> findByName(String inName)
    {
        return strategyInstanceDao.findByName(inName);
    }
    /**
     * directory which is monitored for incoming strategies
     */
    private Path incomingStrategyDirectoryPath;
    /**
     * directory which is used to store uploaded strategies before they are verified
     */
    private Path temporaryStrategyDirectoryPath;
    /**
     * directory which is used to store uploaded strategies after they are verified
     */
    private Path storageStrategyDirectoryPath;
    /**
     * interval at which to poll for provisioning files
     */
    @Value("${metc.strategy.incoming.directory.polling.intervalms:5000}")
    private long pollingInterval;
    /**
     * strategy storage directory base
     */
    @Value("${metc.strategy.storage.directory}")
    private String strategyStorageDirectoryName;
    /**
     * strategy incoming directory base
     */
    @Value("${metc.strategy.incoming.directory}")
    private String strategyIncomingDirectoryName;
    /**
     * strategy temporary directory base
     */
    @Value("${metc.strategy.temporary.directory}")
    private String strategyTemporaryDirectoryName;
    /**
     * name of this service
     */
    private String serviceName;
    /**
     * watches the incoming strategy directory
     */
    private DirectoryWatcherImpl strategyWatcher;
    /**
     * provides access to cluster services
     */
    @Autowired
    private ClusterService clusterService;
    /**
     * provides access to event bus services
     */
    @Autowired
    private EventBusService eventBusService;
    /**
     * generated cluster data
     */
    private ClusterData clusterData;
    /**
     * provides access to the {@link User} data store
     */
    @Autowired
    private UserDao userDao;
    /**
     * provides access to the {@link StrategyInstance} data store
     */
    @Autowired
    private StrategyInstanceDao strategyInstanceDao;
    /**
     * provides access to provisioning services
     */
    @Autowired
    private ProvisioningAgent provisioningAgent;
    /**
     * holds event listener subscribers
     */
    private final Set<StrategyEventListener> strategyEventListeners = Sets.newConcurrentHashSet();
}
