//
// this file is automatically generated
//
package org.marketcetera.strategy;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.NoSuchAlgorithmException;
import java.util.Collection;
import java.util.Date;
import java.util.Optional;
import java.util.concurrent.Callable;

import org.apache.commons.lang3.Validate;
import org.joda.time.Period;
import org.marketcetera.admin.User;
import org.marketcetera.admin.UserFactory;
import org.marketcetera.admin.rpc.AdminRpcUtil;
import org.marketcetera.core.ApplicationVersion;
import org.marketcetera.core.PlatformServices;
import org.marketcetera.core.Preserve;
import org.marketcetera.core.Util;
import org.marketcetera.core.VersionInfo;
import org.marketcetera.core.time.TimeFactoryImpl;
import org.marketcetera.rpc.base.BaseRpc;
import org.marketcetera.rpc.base.BaseRpcUtil;
import org.marketcetera.rpc.client.AbstractRpcClient;
import org.marketcetera.util.log.SLF4JLoggerProxy;
import org.marketcetera.util.ws.tags.AppId;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import com.google.common.collect.Lists;
import com.google.protobuf.ByteString;

import io.grpc.stub.StreamObserver;

/* $License$ */

/**
 * Provides an RPC Client for StrategyRpc services.
 *
 * @author <a href="mailto:colin@marketcetera.com">Colin DuPlantis</a>
 * @version $Id$
 * @since $Release$
 */
@Preserve
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class StrategyRpcClient
        extends AbstractRpcClient<StrategyRpcServiceGrpc.StrategyRpcServiceBlockingStub,StrategyRpcServiceGrpc.StrategyRpcServiceStub,StrategyRpcClientParameters>
        implements StrategyClient
{
    /* (non-Javadoc)
     * @see org.marketcetera.strategy.StrategyClient#findByName(String)
     */
    @Override
    public java.util.Optional<? extends org.marketcetera.strategy.StrategyInstance> findByName(String inName)
    {
        return executeCall(new java.util.concurrent.Callable<java.util.Optional<? extends org.marketcetera.strategy.StrategyInstance>>() {
            @Override
            public java.util.Optional<? extends org.marketcetera.strategy.StrategyInstance> call()
                    throws Exception
            {
                StrategyRpc.FindStrategyInstanceByNameRequest.Builder requestBuilder = StrategyRpc.FindStrategyInstanceByNameRequest.newBuilder();
                requestBuilder.setSessionId(getSessionId().getValue());
                requestBuilder.setName(inName);
                StrategyRpc.FindStrategyInstanceByNameRequest request = requestBuilder.build();
                org.marketcetera.util.log.SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} sending {}",getSessionId(),request);
                StrategyRpc.FindStrategyInstanceByNameResponse response = getBlockingStub().findByName(request);
                org.marketcetera.util.log.SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} received {}",getSessionId(),response);
                if(response.hasStrategyInstance()) {
                    return StrategyRpcUtil.getStrategyInstance(response.getStrategyInstance(),
                                                               strategyInstanceFactory,
                                                               userFactory);
                } else {
                    return Optional.empty();
                }
            }}
        );
    }
    /* (non-Javadoc)
     * @see StrategyClient#getStrategyInstances()
     */
    @Override
    public Collection<? extends StrategyInstance> getStrategyInstances()
    {
        return executeCall(new Callable<Collection<? extends StrategyInstance>>() {
            @Override
            public Collection<? extends StrategyInstance> call()
                    throws Exception
            {
                StrategyRpc.ReadStrategyInstancesRequest.Builder requestBuilder = StrategyRpc.ReadStrategyInstancesRequest.newBuilder();
                requestBuilder.setSessionId(getSessionId().getValue());
                StrategyRpc.ReadStrategyInstancesRequest request = requestBuilder.build();
                SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} sending {}",getSessionId(),request);
                StrategyRpc.ReadStrategyInstancesResponse response = getBlockingStub().getStrategyInstances(request);
                SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} received {}",getSessionId(),response);
                Collection<StrategyInstance> results = Lists.newArrayList();
                response.getStrategyInstancesList().forEach(rpcStrategyInstance -> StrategyRpcUtil.getStrategyInstance(rpcStrategyInstance,
                                                                                                                       strategyInstanceFactory,
                                                                                                                       userFactory).ifPresent(strategyInstance -> results.add(strategyInstance)));
                return results;
            }}
        );
    }
    /* (non-Javadoc)
     * @see org.marketcetera.strategy.StrategyClient#unloadStrategyInstance(String)
     */
    @Override
    public void unloadStrategyInstance(String inStrategyInstanceName)
    {
        executeCall(new java.util.concurrent.Callable<Void>() {
            @Override
            public Void call()
                    throws Exception
            {
                StrategyRpc.UnloadStrategyInstanceRequest.Builder requestBuilder = StrategyRpc.UnloadStrategyInstanceRequest.newBuilder();
                requestBuilder.setSessionId(getSessionId().getValue());
                requestBuilder.setName(inStrategyInstanceName);
                StrategyRpc.UnloadStrategyInstanceRequest request = requestBuilder.build();
                org.marketcetera.util.log.SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} sending {}",getSessionId(),request);
                StrategyRpc.UnloadStrategyInstanceResponse response = getBlockingStub().unloadStrategyInstance(request);
                org.marketcetera.util.log.SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} received {}",getSessionId(),response);
                return null;
            }}
        );
    }
    /* (non-Javadoc)
     * @see StrategyClient#loadStrategyInstance(StrategyInstance)
     */
    @Override
    public StrategyStatus loadStrategyInstance(StrategyInstance inStrategyInstance)
    {
        return executeCall(new Callable<StrategyStatus>() {
            @Override
            public StrategyStatus call()
                    throws Exception
            {
                StrategyRpc.LoadStrategyInstanceRequest.Builder requestBuilder = StrategyRpc.LoadStrategyInstanceRequest.newBuilder();
                requestBuilder.setSessionId(getSessionId().getValue());
                StrategyRpcUtil.getRpcStrategyInstance(inStrategyInstance).ifPresent(rpcValue->requestBuilder.setStrategyInstance(rpcValue));
                StrategyRpc.LoadStrategyInstanceRequest request = requestBuilder.build();
                SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} sending {}",getSessionId(),request);
                StrategyRpc.LoadStrategyInstanceResponse response = getBlockingStub().loadStrategyInstance(request);
                SLF4JLoggerProxy.trace(StrategyRpcClient.this,"{} received {}",getSessionId(),response);
                return StrategyRpcUtil.getStrategyStatus(response.getStatus()).orElse(null);
            }}
        );
    }
    /* (non-Javadoc)
     * @see org.marketcetera.strategy.StrategyClient#uploadFile(org.marketcetera.strategy.FileUploadRequest)
     */
    @Override
    public void uploadFile(org.marketcetera.strategy.FileUploadRequest inRequest)
            throws IOException, NoSuchAlgorithmException
    {
        SLF4JLoggerProxy.trace(this,
                               "Preparing {}",
                               inRequest);
        // TODO this wants to be async, maybe
        FileUploadObserver fileUploadObserver = new FileUploadObserver(inRequest);
        // request observer
        StreamObserver<StrategyRpc.FileUploadRequest> streamObserver = getAsyncStub().uploadFile(fileUploadObserver);
        File uploadFile = new File(inRequest.getFilePath());
        Validate.isTrue(uploadFile.canRead());
        String fileHash = PlatformServices.getFileChecksum(uploadFile);
        StrategyInstance newStrategyInstance = strategyInstanceFactory.create();
        newStrategyInstance.setFilename(uploadFile.getPath());
        newStrategyInstance.setHash(fileHash);
        newStrategyInstance.setName(inRequest.getName());
        newStrategyInstance.setUser(inRequest.getOwner());
        newStrategyInstance.setNonce(inRequest.getNonce());
        // send the strategy instance upload to let them know the file is coming with the proper hash and nonce
        loadStrategyInstance(newStrategyInstance);
        StrategyRpc.FileUploadRequest requestMetadata = StrategyRpc.FileUploadRequest.newBuilder().setMetadata(StrategyTypesRpc.FileUploadMetaData.newBuilder()
            .setName(inRequest.getName())
            .setFilename(inRequest.getFilePath())
            .setHash(fileHash)
            .setNonce(inRequest.getNonce())
            .setOwner(AdminRpcUtil.getRpcUser(inRequest.getOwner()).get())
            .setRequestTimestamp(BaseRpcUtil.getTimestampValue(new Date()).get())
            .build()).build();
        SLF4JLoggerProxy.trace(this,
                               "Submitting {}",
                               requestMetadata);
        long startTimeMillis = System.currentTimeMillis();
        streamObserver.onNext(requestMetadata);
        Path filePath = Paths.get(inRequest.getFilePath());
        long fileSize = Files.size(filePath);
        fileUploadObserver.setFileSize(fileSize);
        // upload file as chunk
        InputStream inputStream = Files.newInputStream(filePath);
        byte[] bytes = new byte[4096];
        int size;
        while((size = inputStream.read(bytes)) > 0) {
            StrategyRpc.FileUploadRequest uploadRequest = StrategyRpc.FileUploadRequest.newBuilder().setFile(StrategyTypesRpc.UploadFile.newBuilder().setContent(ByteString.copyFrom(bytes,0,size)).build()).build();
            streamObserver.onNext(uploadRequest);
            fileUploadObserver.incrementBytesUploaded(size);
        }
        // close the stream
        inputStream.close();
        streamObserver.onCompleted();
        long endTimeMillis = System.currentTimeMillis();
        long elapsedTimeMillis = endTimeMillis - startTimeMillis;
        Period fileUploadPeriod = new Period(elapsedTimeMillis);
        SLF4JLoggerProxy.trace(this,
                               "File upload completed in {}, status: {}",
                               TimeFactoryImpl.periodFormatter.print(fileUploadPeriod),
                               fileUploadObserver.currentStatus);
    }
    private static class FileUploadObserver
            implements StreamObserver<StrategyRpc.FileUploadResponse>
    {
        /**
         * Create a new FileUploadObserver instance.
         *
         * @param inRequest
         */
        public FileUploadObserver(org.marketcetera.strategy.FileUploadRequest inRequest)
        {
            request = inRequest;
        }
        /**
         *
         *
         * @param inSize
         */
        public void incrementBytesUploaded(int inSize)
        {
            bytesUploaded += inSize;
            double percentComplete = bytesUploaded / fileSize;
            request.onProgress(percentComplete);
        }
        private double bytesUploaded = 0;
        /**
         *
         *
         * @param inFileSize
         */
        private void setFileSize(long inFileSize)
        {
            fileSize = inFileSize;
        }
        @Override
        public void onNext(StrategyRpc.FileUploadResponse inFileUploadResponse)
        {
            currentStatus = inFileUploadResponse.getStatus();
            SLF4JLoggerProxy.trace(StrategyRpcClient.class,
                                   "File upload status: {}",
                                   currentStatus);
        }
        @Override
        public void onError(Throwable inError)
        {
            request.onError(inError);
            request.onStatus(FileUploadStatus.FAILED);
        }
        @Override
        public void onCompleted()
        {
            completed = true;
            SLF4JLoggerProxy.trace(StrategyRpcClient.class,
                                   "File upload completed, status is: {}, error is: {}",
                                   currentStatus,
                                   uploadError);
            request.onStatus(uploadError == null ? FileUploadStatus.SUCCESS : FileUploadStatus.FAILED);
        }
        private double fileSize;
        private final org.marketcetera.strategy.FileUploadRequest request;
        private boolean completed = false;
        private Throwable uploadError;
        private StrategyTypesRpc.FileUploadStatus currentStatus = StrategyTypesRpc.FileUploadStatus.UNRECOGNIZED;
    }    
    /* (non-Javadoc)
     * @see AbstractRpcClient#getBlockingStub(io.grpc.Channel)
     */
    @Override
    protected StrategyRpcServiceGrpc.StrategyRpcServiceBlockingStub getBlockingStub(io.grpc.Channel inChannel)
    {
        return StrategyRpcServiceGrpc.newBlockingStub(inChannel);
    }
    /* (non-Javadoc)
     * @see AbstractRpcClient#getAsyncStub(io.grpc.Channel)
     */
    @Override
    protected StrategyRpcServiceGrpc.StrategyRpcServiceStub getAsyncStub(io.grpc.Channel inChannel)
    {
        return StrategyRpcServiceGrpc.newStub(inChannel);
    }
    /* (non-Javadoc)
     * @see AbstractRpcClient#executeLogin(BaseRpc.LoginRequest)
     */
    @Override
    protected BaseRpc.LoginResponse executeLogin(BaseRpc.LoginRequest inRequest)
    {
        return getBlockingStub().login(inRequest);
    }
    /* (non-Javadoc)
     * @see AbstractRpcClient#executeLogout(BaseRpc.LogoutRequest)
     */
    @Override
    protected BaseRpc.LogoutResponse executeLogout(BaseRpc.LogoutRequest inRequest)
    {
        return getBlockingStub().logout(inRequest);
    }
    /* (non-Javadoc)
     * @see AbstractRpcClient#executeHeartbeat(BaseRpc.HeartbeatRequest)
     */
    @Override
    protected BaseRpc.HeartbeatResponse executeHeartbeat(BaseRpc.HeartbeatRequest inRequest)
    {
        return getBlockingStub().heartbeat(inRequest);
    }
    /* (non-Javadoc)
     * @see AbstractRpcClient#getAppId()
     */
    @Override
    protected AppId getAppId()
    {
        return APP_ID;
    }
    /* (non-Javadoc)
     * @see AbstractRpcClient#getVersionInfo()
     */
    @Override
    protected VersionInfo getVersionInfo()
    {
        return APP_ID_VERSION;
    }
    /**
     * Create a new StrategyRpc instance.
     *
     * @param inParameters a <code>StrategyRpcClientParameters</code> value
     */
    protected StrategyRpcClient(StrategyRpcClientParameters inParameters)
    {
        super(inParameters);
    }
    /**
     * creates new {@link StrategyInstance} objects
     */
    @Autowired
    private StrategyInstanceFactory strategyInstanceFactory;
    /**
     * creates new {@link User} objects
     */
    @Autowired
    private UserFactory userFactory;
    /**
     * The client's application ID: the application name.
     */
    public static final String APP_ID_NAME = "StrategyRpc"; //$NON-NLS-1$
    /**
     * The client's application ID: the version.
     */
    public static final VersionInfo APP_ID_VERSION = ApplicationVersion.getVersion(StrategyClient.class);
    /**
     * The client's application ID: the ID.
     */
    public static final AppId APP_ID = Util.getAppId(APP_ID_NAME,APP_ID_VERSION.getVersionInfo());
}
